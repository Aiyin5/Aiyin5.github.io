import{_ as a,V as e,W as r,$ as i}from"./framework-e28fa486.js";const h="/assets/graph/graph_definition.png",d="/assets/graph/undirected_unweight1.png",n="/assets/graph/undirected_unweight2.png",t="/assets/graph/directed_unweight1.png",s="/assets/graph/directed_unweight2.png",c="/assets/graph/undirected_weight.png",p="/assets/graph/directed_weight.png",o={},l=i('<h1 id="图论及基本算法" tabindex="-1"><a class="header-anchor" href="#图论及基本算法" aria-hidden="true">#</a> 图论及基本算法</h1><h2 id="图的组成" tabindex="-1"><a class="header-anchor" href="#图的组成" aria-hidden="true">#</a> 图的组成</h2><p>图是一系列点集合和一系列边集合的二元组</p><figure><img src="'+h+'" alt="图的组成" tabindex="0" loading="lazy"><figcaption>图的组成</figcaption></figure><h3 id="图的分类" tabindex="-1"><a class="header-anchor" href="#图的分类" aria-hidden="true">#</a> 图的分类</h3><p>根据边是否有向，可以分成有向图和无向图，同时根据边是否带权，可以分成有权图和无权图。 所以一般的图可以分成四类，分别是无向无权图、有向无权图、无向有权图、有向有权图。</p><h3 id="图的表示" tabindex="-1"><a class="header-anchor" href="#图的表示" aria-hidden="true">#</a> 图的表示</h3><p>一般有两种方式表示图，分别是邻接矩阵和邻接表。</p><p>邻接表是通过用使用一个Map保存图中所有点及其对应的邻接点。</p><p>邻接矩阵则是通过一个表的横坐标和纵坐标表示图中的所有点，表中的单元格表示其是否连接，在有权图中，也表示权重。</p><p>无向图的邻接矩阵是对阵的，有向图一般是非对称的。</p><h4 id="无向无权图" tabindex="-1"><a class="header-anchor" href="#无向无权图" aria-hidden="true">#</a> 无向无权图</h4><p><img src="'+d+'" alt="无向无权图1" loading="lazy"><img src="'+n+'" alt="无向无权图2" loading="lazy"></p><h4 id="有向无权图" tabindex="-1"><a class="header-anchor" href="#有向无权图" aria-hidden="true">#</a> 有向无权图</h4><p><img src="'+t+'" alt="有向无权图1" loading="lazy"><img src="'+s+'" alt="有向无权图2" loading="lazy"></p><h4 id="无向有权图" tabindex="-1"><a class="header-anchor" href="#无向有权图" aria-hidden="true">#</a> 无向有权图</h4><figure><img src="'+c+'" alt="无向有权图" tabindex="0" loading="lazy"><figcaption>无向有权图</figcaption></figure><h4 id="有向有权图" tabindex="-1"><a class="header-anchor" href="#有向有权图" aria-hidden="true">#</a> 有向有权图</h4><figure><img src="'+p+'" alt="有向有权图" tabindex="0" loading="lazy"><figcaption>有向有权图</figcaption></figure><h3 id="路径" tabindex="-1"><a class="header-anchor" href="#路径" aria-hidden="true">#</a> 路径</h3><p>路径是图中一个点到另外一个点途经的所有边的集合或者点的集合。</p><p>一般来说，我们讨论单源性路径，即一个点到其他点的路径。</p><h2 id="图的遍历" tabindex="-1"><a class="header-anchor" href="#图的遍历" aria-hidden="true">#</a> 图的遍历</h2><p>图的基本遍历方法有两种，分别是广度优先搜索和深度优先搜索。</p><h3 id="广度优先搜索" tabindex="-1"><a class="header-anchor" href="#广度优先搜索" aria-hidden="true">#</a> 广度优先搜索</h3><h3 id="深度优先搜索" tabindex="-1"><a class="header-anchor" href="#深度优先搜索" aria-hidden="true">#</a> 深度优先搜索</h3><h3 id="最短路径" tabindex="-1"><a class="header-anchor" href="#最短路径" aria-hidden="true">#</a> 最短路径</h3><h4 id="无权图的最短路径" tabindex="-1"><a class="header-anchor" href="#无权图的最短路径" aria-hidden="true">#</a> 无权图的最短路径</h4><h4 id="有权图的最短路径" tabindex="-1"><a class="header-anchor" href="#有权图的最短路径" aria-hidden="true">#</a> 有权图的最短路径</h4><h2 id="最小生成树" tabindex="-1"><a class="header-anchor" href="#最小生成树" aria-hidden="true">#</a> 最小生成树</h2><h3 id="树和图的区别" tabindex="-1"><a class="header-anchor" href="#树和图的区别" aria-hidden="true">#</a> 树和图的区别</h3><p>树是一种特殊的图，对图进行一些约束就是称为树。</p><p>一种无向的没有环的连通图就是树。</p><h3 id="最小生成树的定义" tabindex="-1"><a class="header-anchor" href="#最小生成树的定义" aria-hidden="true">#</a> 最小生成树的定义</h3><p>生成树是指一个图中的子图，包含图中所有的节点，边数为节点数减一，满足树的三个特征，无环，连通且无向。</p><p>图的最小生成树就是所有生成树中路径和最小的一个。</p><p>有一些图是没有生成树的，类似非连通图就没有。</p><h4 id="获取最小生成树的算法" tabindex="-1"><a class="header-anchor" href="#获取最小生成树的算法" aria-hidden="true">#</a> 获取最小生成树的算法</h4><h5 id="prim算法" tabindex="-1"><a class="header-anchor" href="#prim算法" aria-hidden="true">#</a> Prim算法</h5><h5 id="kruskal算法" tabindex="-1"><a class="header-anchor" href="#kruskal算法" aria-hidden="true">#</a> Kruskal算法</h5>',40),g=[l];function u(f,_){return e(),r("div",null,g)}const b=a(o,[["render",u],["__file","图论整理.html.vue"]]);export{b as default};
